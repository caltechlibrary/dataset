<!DOCTYPE html>
<html>
<head>
    <title>Caltech Library's Digital Library Development Sandbox</title>
    <link rel="stylesheet" href="/css/site.css">
</head>
<body>
<header>
<a href="https://library.caltech.edu"><img src="/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
<li>
<a href="/">Home</a>
</li>
<li>
<a href="../">Up</a>
</li>
<li>
<a href="../">README</a>
</li>
<li>
<a href="../license.html">LICENSE</a>
</li>
<li>
<a href="../install.html">INSTALL</a>
</li>
<li>
<a href="../docs/">Documentation</a>
</li>
<li>
<a href="./">Tutorials</a>
</li>
<li>
<a href="../docs/topics.html">Topics</a>
</li>
<li>
<a href="../about.html">About</a>
</li>
<li>
<a href="https://github.com/caltechlibrary/dataset">Github</a>
</li>
<li>
<a
href="https://github.com/caltechlibrary/dataset/releases/">Releases</a>
</li>
</ul>
</nav>

<section>
<h1 id="getting-started-with-dataset">
Getting started with dataset
</h1>
<p>
<em>dataset</em> is designed to easily manage collections of JSON
documents. A JSON object is associated with a unique key you provide. If
you are using the default storage engine the objects themselves are
stored on disc in a folder inside the collection folder. If you are
using a SQL storage engine they are stored in a column of a table of the
collection in your SQL database.
</p>
<p>
The collection folder contains a JSON object document called
<em>collection.json</em>. This file stores operational metadata about
the collection. If the collection is using a pairtree then a
<em>keymap.json</em> file will include the association of keys with
paths to their objects. When a collection is initialized a minimal
codemeta.json file will created describing the collection. This can be
update to a full codemeta.json file, follow the guideline and practice
described at the <a href="https://codemeta.github.io">codemeta</a>
website.
</p>
<p>
<em>dataset</em> comes in several flavors — a command line program
called <em>dataset</em>, a web service called <em>datasetd</em> and the
Go language package used to build for programs.
</p>
<p>
This tutorial talks both the command line program and the Go package.
The command line is great for simple setup, the Go package allows you to
build on other programs that use dataset collections for content
persistence.
</p>
<h2 id="create-a-collection-with-init">
Create a collection with init
</h2>
<p>
To create a collection you use the init verb. In the following examples
you will see how to do this with both the command line tool
<em>dataset</em> as well as the Python module of the same name.
</p>
<p>
Let’s create a collection called <em>friends.ds</em>. At the command
line type the following.
</p>
<div id="cb1" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> init friends.ds</span></code></pre>
</div>
<p>
Notice that after you typed this and press enter you see an “OK”
response. If there had been an error then you would have seen an error
message instead.
</p>
<p>
Working in Go is similar. We use the <code>dataset.Init()</code> func to
create our new collection. We can import the “dataset” package using the
import line <code>“github.com/caltechlibrary/dataset”</code>. Here’s a
general code sketch.
</p>
<pre class="golang"><code>   import (
      // import the packages your program needs ...
      &quot;fmt&quot;
      &quot;os&quot;

      // import dataset
      &quot;github.com/caltechlibrary/dataset&quot;
   )
        
   func main() {
       // The dataset collection is held in &#39;c&#39;
       // This create the collection &quot;friends.ds&quot;
       collectionName := &quot;frieds.ds&quot;
       // &quot;c&quot; is a handle to the collection
       c, err := dataset.init(collectionName)
       if err != nil {
           fmt.Fprintf(os.Stderr, &quot;Something went wrong, %s\n&quot;, err)
           os.Exit(1)
       }
       defer c.Close() // Remember to close your collection
       fmt.Printf(&quot;Created %q, ready to use\n&quot;, collectionName)
   }</code></pre>
<p>
In this Go example if the error is nil a statement is written to
standard out saying the collection was created, if not an error is
shown.
</p>
<h3 id="removing-friends.ds">
removing friends.ds
</h3>
<p>
There is no dataset verb to remove a collection. A collection is just a
folder with some files in it. You can delete the collection by throwing
the folder in the trash (Mac OS X and Windows) or using a recursive
remove in the Unix shell.
</p>
<pre class="shell"><code>    rm -fR friends.ds</code></pre>
<p>
Or using <code>os.RemoveAll()</code> in Go programs.
</p>
<pre><code>    if _, err := os.Stat(collectionName); err == nil {
        os.RemoveAll(collectionName)
    }</code></pre>
<h2 id="create-read-update-and-delete">
create, read, update and delete
</h2>
<p>
As with many systems that store information dataset provides for basic
operations of creating, updating and deleting. In the following section
we will work with the <em>friends.ds</em> collection and
<em>favorites.ds</em> collection we created previously.
</p>
<p>
I have some friends who are characters in <a
href="https://zbs.org">ZBS</a> radio plays. I am going to create and
save some of their info in our collection called <em>friends.ds</em>. I
am going to store their name and email address so I can contact them.
Their names are Little Frieda, Mojo Sam and Jack Flanders.
</p>
<div id="cb5" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> create friends.ds frieda <span class="dt">\</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>      <span class="st">&#39;{&quot;name&quot;:&quot;Little Frieda&quot;,&quot;email&quot;:&quot;frieda@inverness.example.org&quot;}&#39;</span></span></code></pre>
</div>
<p>
Notice the “OK”. Just like <em>init</em> the <em>create</em> verb
returns a status. “OK” means everything is good, otherwise an error is
shown.
</p>
<p>
Doing the same thing in Go would look like. Note we have to explicitly
<code>Open()</code> the collection to get a collection object then call
<code>Create()</code> on the opened collection. <code>defer</code> make
it easy for us to remember to close the collection when we’re done.
</p>
<pre class="golang"><code>    import (
        &quot;fmt&quot;
        &quot;os&quot;

        &quot;github.com/caltechlibrary/dataset&quot;
    )

    func main() {
        c, err := dataset.Open(&quot;fiends.ds&quot;)
        if err != nil {
            fmt.Fprintf(os.Stderr, &quot;something went wrong, %s&quot;, err)
            os.Exit(1)
        }
        defer c.Close() // Don&#39;t forget to close the collection
        id := &quot;frieda&quot;
        m := map[string]interface{}{
            &quot;id&quot;: id,
            &quot;name&quot;:&quot;Little Frieda&quot;,
            &quot;email&quot;:&quot;frieda@inverness.example.org&quot;,
        }
        // Create adds a map[string]interface{} to the collection.
        if err := dataset.Create(id, m); err != nil {
            fmt.Fprintf(os.Stderr, &quot;%s&quot;,err)
            os.Exit(1)
        }
        fmt.Printf(&quot;OK&quot;)
        os.Exit(0)
    }</code></pre>
<p>
Go supports easy translation of struct types into JSON encoded byte
slices. Can then use that store the JSON representations using the
<code>CreateObject()</code> to create a JSON object from any Go type.
</p>
<pre class="golang"><code>   import (
      &quot;encoding/json&quot;
      &quot;fmt&quot;
      &quot;os&quot;

      &quot;github.com/caltechlibrary/dataset&quot;
   )

   type Record struct {
       ID string `json:&quot;id&quot;`
       Name string `json:&quot;name,omitempty&quot;`
       EMail string `json:&quot;email,omitempty&quot;`
   }

   func main() {
       obj := &amp;Record{
           ID: &quot;frieda&quot;,
           Name: &quot;Little Fieda&quot;,
           EMail: &quot;frieda@inverness.example.org&quot;,
       }
       if err := dataset.CreateObject(&quot;friends.ds&quot;, obj.ID, obj); err != nil {
           fmt.Fprintf(os.Stderr, &quot;%s&quot;, err)
           os.Exit(1)
       }
       fmt.Printf(&quot;OK&quot;)
       os.Exit(0)
   }</code></pre>
<p>
On the command line create requires us to provide a collection name, a
key (e.g. “frieda”) and JSON markup to store the JSON object. We can
provide that either through the command line or by reading in a file or
standard input.
</p>
<p>
command line –
</p>
<div id="cb8" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span> <span class="op">&lt;&lt;EOT</span> <span class="op">&gt;</span>mojo.json</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="st">    {</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;id&quot;: &quot;mojo&quot;,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;name&quot;: &quot;Mojo Sam, the Yudoo Man&quot;, </span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;email&quot;: &quot;mojosam@cosmic-cafe.example.org&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="st">    EOT</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="st">    cat mojo.json | dataset create friends.ds &quot;mojo&quot;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="st">    cat &lt;&lt;EOT &gt;jack.json</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="st">    {</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;id&quot;: &quot;jack&quot;,</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;name&quot;: &quot;Jack Flanders&quot;, </span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;email&quot;: &quot;capt-jack@cosmic-voyager.example.org&quot;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="st">     </span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="st">    EOT</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="st">    dataset create -i jack.json friends.ds &quot;jack&quot;</span></span></code></pre>
</div>
<p>
in Go we can loop through records easily and add them –
</p>
<pre class="golang"><code>    // Open the collection
    c, err := dataset.Open(&quot;friends.ds&quot;)
    if err != nil {
        ...
    }
    defer c.Close()// Don&#39;t forget to close the collection

    // Create some new records
    newRecords := []Record{
        Record{
            ID: &quot;mojo&quot;,
            Name: &quot;Mojo Sam&quot;,
            EMail: &quot;mojosam@cosmic-cafe.example.rog&quot;,
        },
        Record{
            ID: &quot;jack&quot;,
            Name: &quot;Jack Flanders&quot;,
            Email: &quot;capt-jack@cosmic-voyager.example.org&quot;,
        },
    }
    // Save the new records into the collection
    for _, record := range newRecords {
        if err := dataset.CreateObject(record.ID, record); err != nil {
            fmt.Fprintf(os.Stderr, 
               &quot;something went wrong add %q, %s\n&quot;, record.ID, key)
        }
    }</code></pre>
<h3 id="read">
read
</h3>
<p>
We have three records in our <em>friends.ds</em> collection — “frieda”,
“mojo”, and “jack”. Let’s see what they look like with the <em>read</em>
verb.
</p>
<p>
command line –
</p>
<div id="cb10" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> read friends.ds frieda</span></code></pre>
</div>
<p>
On the command line you can easily pipe the results to a file for latter
modification. Let’s do this for each of the records we have created so
far.
</p>
<div id="cb11" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> read <span class="at">-p</span> friends.ds frieda <span class="op">&gt;</span>frieda-profile.json</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> read <span class="at">-p</span> friends.ds mojo <span class="op">&gt;</span>mojo-profile.json</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> read <span class="at">-p</span> friends.ds jack <span class="op">&gt;</span>jack-profile.json</span></code></pre>
</div>
<p>
Working in Go is similar but rather than write out our JSON structures
to a file we’re going to keep them in memory as an array of record
structs before converting to JSON and writing it out.
</p>
<p>
In Go –
</p>
<pre class="golang"><code>    // Open our collection
    c, err := dataset.Open(&quot;friends.ds&quot;)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;%s\n&quot;, err)
        os.Exit(1)
    }
    defer c.Close() // remember to close the collection

    // build our list of keys
    keys := []string{ &quot;frieda&quot;, &quot;mojo&quot;, &quot;jack&quot; }
    records := []*Record{}
    // loop through the list and write the JSON source to file.
    for _, key := range keys {
       obj := &amp;Record{}
       if err := c.ReadObject(key, &amp;obj); err != nil {
           fmt.Fprintf(os.Stderr, &quot;%s\n&quot;, err)
           os.Exit(1)
       }  
       records = append(records, obj)
    }
    src, _ := json.MarshalIndent(records)
    fmt.Println(&quot;%s\n&quot;, src)
    os.Exit(0)</code></pre>
<h3 id="update">
update
</h3>
<p>
Next we can modify the profiles (the *.json files for the command line
version). We’re going to add a key/value pair for “catch_phrase”
associated with each JSON object in <em>friends.ds</em>. For Little
Frieda edit freida-profile.json to look like –
</p>
<div id="cb13" class="sourceCode">
<pre
class="sourceCode json"><code class="sourceCode json"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;_Key&quot;</span><span class="fu">:</span> <span class="st">&quot;frieda&quot;</span><span class="fu">,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;email&quot;</span><span class="fu">:</span> <span class="st">&quot;frieda@inverness.example.org&quot;</span><span class="fu">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Little Frieda&quot;</span><span class="fu">,</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;catch_phrase&quot;</span><span class="fu">:</span> <span class="st">&quot;Woweee Zoweee&quot;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span></code></pre>
</div>
<p>
For Mojo’s mojo-profile.json –
</p>
<div id="cb14" class="sourceCode">
<pre
class="sourceCode json"><code class="sourceCode json"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;_Key&quot;</span><span class="fu">:</span> <span class="st">&quot;mojo&quot;</span><span class="fu">,</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;email&quot;</span><span class="fu">:</span> <span class="st">&quot;mojosam@cosmic-cafe.example.org&quot;</span><span class="fu">,</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Mojo Sam, the Yudoo Man&quot;</span><span class="fu">,</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;catch_phrase&quot;</span><span class="fu">:</span> <span class="st">&quot;Feet Don&#39;t Fail Me Now!&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span></code></pre>
</div>
<p>
An Jack’s jack-profile.json –
</p>
<div id="cb15" class="sourceCode">
<pre
class="sourceCode json"><code class="sourceCode json"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;_Key&quot;</span><span class="fu">:</span> <span class="st">&quot;jack&quot;</span><span class="fu">,</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;email&quot;</span><span class="fu">:</span> <span class="st">&quot;capt-jack@cosmic-voyager.example.org&quot;</span><span class="fu">,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Jack Flanders&quot;</span><span class="fu">,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;catch_phrase&quot;</span><span class="fu">:</span> <span class="st">&quot;What is coming at you is coming from you&quot;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span></code></pre>
</div>
<p>
On the command line we can read in the updated JSON objects and save the
results in the collection with the <em>update</em> verb. Like with
<em>init</em> and <em>create</em> the <em>update</em> verb will return
an “OK” or error message. Let’s update each of our JSON objects.
</p>
<div id="cb16" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> update friends.ds freida frieda-profile.json</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> update friends.ds mojo mojo-profile.json</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> update friends.ds jack jack-profile.json</span></code></pre>
</div>
<p>
<strong>TIP</strong>: By providing a filename ending in “.json” the
dataset command knows to read the JSON object from disc. If the object
had stated with a “{” and ended with a “}” it would assume you were
using an explicit JSON expression.
</p>
<p>
In Go we can work with each of the record as
<code>map[string]interface{}</code> variables. We save from our previous
<em>Read</em> example. We add our “catch_phrase” attribute then
<em>Update</em> each record.
</p>
<pre class="golang"><code>    c, err := dataset.Open(&quot;friends.ds&quot;)
    if err != nil { 
        // ... handle errors
    }
    defer c.Close()

    // Read our three profiles
    friedaProfile := map[string]interface{}{}
    if err := c.Read(&quot;frieda&quot;, fredaProfile); err != nil {
        // ... handle error
    }
    mojoProfile := map[string]interface{}{}
    if err :=  c.Read(&quot;mojo&quot;, mojoProfile); err != nil  {
        // ... handle error
    }
    jackProfile := map[string]interface{}{}
    if err := c.Read(&quot;jack&quot;, jackProfile); err != nil {
        // ... handle error
    }
    
    // Add our catch phrases
    friedaProfile[&quot;catch_phrase&quot;] = &quot;Wowee Zowee&quot;
    mojoProfile[&quot;catch_phrase&quot;] = &quot;Feet Don&#39;t Fail Me Now!&quot;
    jackProfile[&quot;catch_phrase&quot;] = &quot;What is coming at you is coming from you&quot;
    
    // Update our records
    if err := c.Update(&quot;frieda&quot;, friedaProfile); err != &quot;&quot; {
        // ... handle error
    }
    if err := c.Update(&quot;mojo&quot;, mojoProfile); err != &quot;&quot; {
        // ... handle error
    }
    if err := c.Update(&quot;jack&quot;, jackProfile); err != nil {
        // ... handle error
    }</code></pre>
<p>
A better approach where we would be to use a Go struct to hold the
profile records. This would ensure that they mapping of attribute names
are consistently handled.
</p>
<pre class="golang"><code>    import (
        &quot;github.com/caltechlibrary/dataset&quot;
    )

    type Profile struct {
        Name string `json:&quot;name&quot;`
        EMail string `json:&quot;email,omitempty&quot;`
        CatchPhrase string `json:&quot;catech_phrase,omitempty&quot;`
    }

    func main() {
        // Load our minimal records, i.e. name and email
        records := map[string]*Profile{}{
            &quot;frieda&quot;: &amp;Profile{ 
                Key: &quot;frieda&quot;, 
                EMail: &quot;frieda@inverness.example.org&quot;,
                Name: &quot;Little Frieda&quot;, 
                },
            &quot;mojo&quot;: &amp;Profile{
                Key: &quot;mojo&quot;,
                EMail: &quot;mojosam@cosmic-cafe.example.org&quot;,
                Name: &quot;Mojo Sam, the Yudoo Man&quot;,
            },
            &quot;jack&quot;: &amp;Profile{
                Key: &quot;jack&quot;,
                EMail: &quot;capt-jack@cosmic-voyager.example.org&quot;,
                Name: &quot;Jack Flanders&quot;,
            },
        }

        // Create the collection and add our records
        c, err := dataset.Init(&quot;friends.ds&quot;, &quot;&quot;)
        if err != nil {
            // ... handle errror
        }
        for key, record := range records {
            if err := c.CreateObject(key, recorrd); err != nil {
                // ... handle error
            }
        }

        // Add our catch phrases
    
        records[&quot;frieda&quot;].CatchPhrase = &quot;Wowee Zowee&quot;
        records[&quot;mojo&quot;].CatchPhrase = &quot;Feet Don&#39;t Fail Me Now!&quot;
        records[&quot;jack&quot;].CatchPhrase = 
             &quot;What is coming at you is coming from you&quot;
    
        // Update our records
        for key, record := range records {
            if err := c.UpdateObject(key, record); err != &quot;&quot; {
                // ... handle error
            }
        }
    }</code></pre>
<h3 id="delete">
delete
</h3>
<p>
Eventually you might want to remove a JSON object from the collection.
Let’s remove Jack Flander’s record for now.
</p>
<p>
command line –
</p>
<div id="cb19" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> delete friends.ds jack</span></code></pre>
</div>
<p>
Notice the “OK” in this case it means we’ve successfully delete the JSON
object from the collection.
</p>
<p>
An perhaps as you’ve already guessed working in Go looks like –
</p>
<pre class="golang"><code>   c, err := dataset.Open(&quot;friends.ds&quot;)
   if err != nil {
       // ... handle error
   }
   defer c.Close()

   if err := c.Delete(&quot;jack&quot;); err != nil {
       fmt.Fprintf(os.Stderr, &quot;%s\n&quot;, err)
       os.Exit(1)
   }
   fmt.Println(&quot;OK&quot;)
   os.Exit(0)</code></pre>
<h2 id="keys-and-count">
keys and count
</h2>
<p>
Eventually you have lots of objects in your collection. You are not
going to be able to remember all the keys. dataset provides a
<em>keys</em> function for getting a list of keys as well as a
<em>count</em> to give you a total number of keys.
</p>
<p>
Now that we’ve deleted a few things let’s see how many keys are in
<em>friends.ds</em>. We can do that with the <em>count</em> verb.
</p>
<p>
Command line –
</p>
<div id="cb21" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> count friends.ds</span></code></pre>
</div>
<p>
In Go –
</p>
<pre class="golang"><code>   c, err := dataset.Open(&quot;friends.ds&quot;)
   if err != nil {
       // ... handle error
   }
   defer c.Close()

   cnt = c.Length() // NOTE: this is an int64 value
   fmt.Printf(&quot;Total Records Now: %d\n&quot;, cnt)</code></pre>
<p>
Likewise we can get a list of the keys with the <em>keys</em> verb.
</p>
<div id="cb23" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> keys friends.ds</span></code></pre>
</div>
<p>
If you are following along in Go then you can just save the keys to a
variable called keys.
</p>
<pre class="golang"><code>   c, err := dataset.Open(&quot;friends.ds&quot;)
   if err != nil {
       // ... handle error
   }
   defer c.Close()

   keys, err = c.Keys()
   if err != nil {
       // ... handle error
   }
   fmt.Printf(&quot;%s\n&quot;, strings.Join(keys, &quot;\n&quot;))</code></pre>
<h2 id="data-frames">
Data frames
</h2>
<p>
JSON objects are tree like. This structure can be inconvenient for some
types of analysis like tabulation, comparing values or generating
summarizing reports. Many languages support a concept of “data frame”.
Meaning a list of objects, possibly with associated metadata about how
the list was created. This becomes a convenient way to process data.
Frames can easily be transformed.
</p>
<h3 id="the-frame">
the frame
</h3>
<p>
dataset also comes with a <em>frame</em> verb. A <em>frame</em> is an
order list of objects based on a set of keys and metadata about how the
values for the objects we mapped from the collection’s JSON documents.
It is similar to the “data frames” concepts in languages like Julia,
Matlab, Octave, Python and R.
</p>
<p>
To define a frame we only need two pieces of information, a list of keys
in the collection to be framed and a list of dot notated paths to map
into a set of labels for the object in the frame.
</p>
<div id="cb25" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame-create <span class="at">-i</span><span class="op">=</span>friends.keys friends.ds <span class="dt">\</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;name-and-email&quot;</span> <span class="dt">\</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        .name=name .email=email <span class="dt">\</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        .catch_phrase=catch_phrase</span></code></pre>
</div>
<p>
In Go it would look like
</p>
<div id="cb26" class="sourceCode">
<pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    c, err :<span class="op">=</span> dataset.Open(<span class="st">&quot;friends.ds&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">//</span> ... handle error</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    defer c.Close()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    verbose :<span class="op">=</span> true</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    keys <span class="op">=</span> c.Keys()</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    dotPaths :<span class="op">=</span> []string{ <span class="st">&quot;.name&quot;</span>, <span class="st">&quot;.email&quot;</span>, <span class="st">&quot;.catch_phrase&quot;</span> }</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    labels :<span class="op">=</span> []string{ <span class="st">&quot;name&quot;</span>, <span class="st">&quot;email&quot;</span>, <span class="st">&quot;catch_phrase&quot;</span> }</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err :<span class="op">=</span> c.FrameCreate(<span class="st">&quot;friends.ds&quot;</span>, <span class="st">&quot;name-and-email&quot;</span>, </span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>                keys, dotPaths, labels, verbose)<span class="op">;</span> err <span class="op">!=</span> nil {</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">//</span> ... handle error</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre>
</div>
<p>
In Go it’d look like
</p>
<pre class="golang"><code>    c, err := dataset.Open(&quot;friends.ds&quot;)
    // ... handle error
    defer c.Close()

    frm, err := c.FrameRead(&quot;name-and-email&quot;)
    // ... handle error
    src, err := json.MarshalIndent(frm, &quot;&quot;, &quot;    &quot;)
    // ... handle error
    fmt.Printf(&quot;%s\n&quot;, src)</code></pre>
<p>
Looking at the resulting JSON object you see other attributes beyond the
object list of the frame. These are created to simplify some of dataset
more complex interactions.
</p>
<p>
Most of the time you don’t want the metadata, so you we have a way of
just retrieving the object list.
</p>
<div id="cb28" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame-objects friends.ds <span class="st">&quot;name-and-email&quot;</span></span></code></pre>
</div>
<p>
Or in Go –
</p>
<pre class="golang"><code>    c, err := dataset.Open(&quot;friends.ds&quot;)
    // ... handle error
    defer c.Close()

    objects, err := c.FrameObjects(&quot;name-and-email&quot;)
    // ... handle error
    src, err := json.MarshalIndent(objects, &quot;&quot;, &quot;    &quot;)
    // ... handle error
    fmt.Printf(&quot;%s\n&quot;, src)</code></pre>
<p>
Let’s add back the Jack record we deleted a few sections ago and
“reframe” our “name-and-email” frame.
</p>
<div id="cb30" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adding back Jack</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> create <span class="at">-i</span> jack-profile.json friends.ds jack</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save all the keys in the collection</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> keys friends.ds <span class="op">&gt;</span>friends.keys</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now reframe &quot;name-and-email&quot; with the updated friends.keys</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> reframe <span class="at">-i</span><span class="op">=</span>friends.keys friends.ds <span class="st">&quot;name-and-email&quot;</span> </span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now let&#39;s take a look at the frame&#39;s objects</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame-objects friends.ds <span class="st">&quot;name-and-email&quot;</span></span></code></pre>
</div>
<p>
Let’s try the same thing in Go –
</p>
<pre class="golang"><code>   c, err := dataset.Open(&quot;friends.ds&quot;)
   // ... handle error
   defer c.Close()
   if err := c.CreateObject(&quot;jack&quot;, jackProfile); err != nil {
       // ... handle error
   }
   keys, err := c.Keys()
   if err != nil {
       // ... handle error
   }
   if err := c.Reframe(&quot;name-and-email&quot;, keys); err != nil {
       // ... handle error
   }
   objects, err := c.FrameObjects(&quot;name-and-email&quot;)
   // ... handle error
   src, err := json.MarshalIndent(objects, &quot;&quot;, &quot;    &quot;)
   // ... handle error
   fmt.Printf(&quot;%s\n&quot;, src)</code></pre>
<p>
We can list the frames in the collection using the <em>frames</em> verb.
</p>
<div id="cb32" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frames friends.ds</span></code></pre>
</div>
<p>
In Go –
</p>
<pre class="golang"><code>   c, err := dataset.Open(&quot;friends.ds&quot;)
   // ... handle error
   defer c.Close()

   frameNames := c.Frames()
   fmt.Printf(&quot;%s\n&quot;, string.Join(frame_names, &quot;\n&quot;))</code></pre>
<p>
In our frame we have previously defined three columns, looking at the
JSON representation of the frame we also see a “labels” attribute.
Labels are used when exporting and synchronizing content between a CSV
file, Google Sheet and a collection (labels become column names).
</p>
<p>
Labels are the target attribute name. They are set at the time of frame
definition and persist as long as the frame exists. The order of the
columns reflects the order of the pairs defining the dot paths and
labels. In our previous examples we provided the order of the columns
for the frame “name-and-email” as <code>.name</code>,
<code>.email</code>, <code>.catch_phrase</code> dot paths. If we want to
have the labels “ID”, “Display Name”, “EMail”, and “Catch Phrase” we
need to define our frame that way.
</p>
<div id="cb34" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame-keys friends.ds <span class="op">&gt;</span>keys.json </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame-delete friends.ds <span class="st">&quot;name-and-email&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame <span class="at">-i</span> keys.json friends.ds <span class="st">&quot;name-and-email&quot;</span> <span class="dt">\</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;._Key=ID&quot;</span> <span class="st">&quot;.name=Display Name&quot;</span> <span class="dt">\</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;.email=EMail&quot;</span> <span class="st">&quot;.catch_phrase=Catch Phrase&quot;</span></span></code></pre>
</div>
<p>
In Go it might look like
</p>
<pre class="golang"><code>    c, err := dataset.Open(&quot;friends.ds&quot;)
    // ... handle error
    defer c.Close()

    verbose := true
    keys, err := c.FrameKeys(&quot;name-and-email&quot;)
    // ... handle error
    frm, err := c.FrameRead(&quot;name-and-email&quot;)
    // ... handle error

    // Retrieve our dot paths and labels then append
    // the additional path and label
    dotPaths := frm.DotPaths
    dotPaths = append(dotPaths, &quot;.catch_phrase&quot;)
    labels := frm.Labels
    labels = append(labels, &quot;catch_phrase&quot;)

    err := c.FrameDelete(&quot;name-and-email&quot;)
    // ... handle error

    err := c.Frame(&quot;name-and-email&quot;, keys, dotPath, labels, verbose)
    if err != nil {
        // ... handle error
    }</code></pre>
<p>
Finally the last thing we need to be able to do is delete a frame.
Delete frames work very similar to deleting a JSON record.
</p>
<div id="cb36" class="sourceCode">
<pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">dataset</span> frame-delete friends.ds <span class="st">&quot;name-and-email&quot;</span></span></code></pre>
</div>
<p>
Or in Go –
</p>
<pre class="golang"><code>   c, err := dataset.Open(&quot;friends.ds&quot;)
   // ... handle
   defer c.Close()

   err := c.FrameDelete(&quot;name-and-email&quot;)
   // ... handle error</code></pre>
<p>
<strong>TIP</strong>: Frames like collections have a number of
operations. Here’s the list
</p>
<ol type="1">
<li>
<p>
<em>frame</em> will let you define a frame
</p>
</li>
<li>
<p>
<em>frame-def</em> will let you read back a frame’s definition
</p>
</li>
<li>
<p>
<em>frame-objects</em> return the frame’s object list
</p>
</li>
<li>
<p>
<em>frame-keys</em> return the frame’s key list
</p>
</li>
<li>
<p>
<em>frames</em> will list the frames defined in the collection columns
in a frame, it will cause the frame to regenerate its object list
</p>
</li>
<li>
<p>
<em>delete-frame</em> will remove the frame from the collection
</p>
</li>
<li>
<p>
<em>refresh</em> will let you refresh the objects in a frame from the
current state of the collection, it’ll prune any existing objects in the
frame is they no longer exist.
</p>
</li>
<li>
<p>
<em>reframe</em> will take a new list of keys from the colletion
recreating ( (replacing) the objects in the data frame based on the new
list of keys
</p>
</li>
</ol>
</section>

<footer>
<span><h1><A href="https://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2021 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
<!-- START: PrettyFi from https://github.com/google/code-prettify -->
<script>
/* We want to add the class "prettyprint" to all the pre elements */
var pre_list = document.querySelectorAll("pre");

pre_list.forEach(function(elem) {
    elem.classList.add("prettyprint");
    elem.classList.add("linenums");/**/
    elem.classList.add("json"); /**/
});
</script>
<style>
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    color: #555;
    list-style-type: decimal;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/prettify.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_
prettify.js"></script>
<!--  END: PrettyFi from https://github.com/google/code-prettify -->
</body>
</html>
